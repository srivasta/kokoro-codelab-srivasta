<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TEST_STRINGS: string_test.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>string_test.c</h1><a href="string__test_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*                               -*- Mode: C -*- </span>
00002 <span class="comment"> * string_test.c --- </span>
00003 <span class="comment"> * Author           : Manoj Srivastava ( srivasta@glaurung.green-gryphon.com ) </span>
00004 <span class="comment"> * Created On       : Thu Feb 20 12:43:59 2003</span>
00005 <span class="comment"> * Created On Node  : glaurung.green-gryphon.com</span>
00006 <span class="comment"> * Last Modified By : Manoj Srivastava</span>
00007 <span class="comment"> * Last Modified On : Thu Feb 27 17:53:16 2003</span>
00008 <span class="comment"> * Last Machine Used: ember.green-gryphon.com</span>
00009 <span class="comment"> * Update Count     : 285</span>
00010 <span class="comment"> * Status           : Unknown, Use with caution!</span>
00011 <span class="comment"> * HISTORY          : </span>
00012 <span class="comment"> * Description      : </span>
00013 <span class="comment"> * </span>
00014 <span class="comment"> */</span>
00015 
<a name="l00016"></a><a class="code" href="string__test_8c.html#a4">00016</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="string__test_8c.html#a4">version</a> = 
00017   <span class="stringliteral">"$Id: string_test.c,v 1.6 2003/03/03 01:36:47 srivasta Exp $"</span>;
00018 <span class="comment"></span>
00019 <span class="comment">/** @file string_test.c</span>
00020 <span class="comment"> *  @ingroup Utilities</span>
00021 <span class="comment"> *  @brief An sample implementation of common string functions</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * Copyright (C) 2003 Manoj Srivastava</span>
00024 <span class="comment"> *</span>
00025 <span class="comment"> * This is my entry for the code challenge. I do make use of the</span>
00026 <span class="comment"> * string.h header file, but only in the regression testing area,</span>
00027 <span class="comment"> * where my reimplementation of the string functions are tested</span>
00028 <span class="comment"> * against the libc versions. </span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> * These functions are rather more straight forward than those I am</span>
00031 <span class="comment"> * used to coding, and is therefore terser, and with fewer comments,</span>
00032 <span class="comment"> * than is my natural style -- all except the Boyer-Moore</span>
00033 <span class="comment"> * implementation in strstr, which was by far the most challenging. </span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> * I had fun coding this. I had forgotten how liberating C can be,</span>
00036 <span class="comment"> * coming back from C++ and java.</span>
00037 <span class="comment"> */</span>
00038 <span class="comment"></span>
00039 <span class="comment">/*! @mainpage This weeks code challenge (NLUG)</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> * \section intro Introduction</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> * This code was written in response to a weekly code challenge for my</span>
00044 <span class="comment"> * local Linux Users Group. It is meant to be an example of coding</span>
00045 <span class="comment"> * techniques for people who are not professional programmers.  I</span>
00046 <span class="comment"> * hoped to demonstrate that a coding assignment is often far more</span>
00047 <span class="comment"> * than just writing code; a testing framework to demonstrate</span>
00048 <span class="comment"> * correctness and testing use cases, as well as detailed</span>
00049 <span class="comment"> * documentation for the end user as well as any future maintainers</span>
00050 <span class="comment"> * are critical and integral components of the expected deliverables.</span>
00051 <span class="comment"> * </span>
00052 <span class="comment"> *</span>
00053 <span class="comment"> * \section string Why string.h?</span>
00054 <span class="comment"> *</span>
00055 <span class="comment"> * For the most part, these string functions are familiar to even new</span>
00056 <span class="comment"> * practitioners of the C language, and are easy to implement. Since</span>
00057 <span class="comment"> * there are reference implementations of all these functions redily</span>
00058 <span class="comment"> * available on most platforms, writing the test harness is also</span>
00059 <span class="comment"> * trivial, so this material should not be intimidating to most</span>
00060 <span class="comment"> * students. </span>
00061 <span class="comment"> *</span>
00062 <span class="comment"> * \subsection functions Functions implemented </span>
00063 <span class="comment"> *  </span>
00064 <span class="comment"> * The following subset of string functions were implemented.</span>
00065 <span class="comment"> *       - size_t strlen(const char *s);</span>
00066 <span class="comment"> *       - char  *strdup(const char *s);</span>
00067 <span class="comment"> *       - char  *strtok(char *s, const char *delim);</span>
00068 <span class="comment"> *       - char  *strtok_r(char *s, const char *delim, char **ptrptr);</span>
00069 <span class="comment"> *       - char  *strchr(const char *s, int c);</span>
00070 <span class="comment"> *       - char  *strstr(const char *haystack, const char *needle);</span>
00071 <span class="comment"> *       - int    strcmp(const char *s1, const char *s2);</span>
00072 <span class="comment"> *       - int    strncmp(const char *s1, const char *s2, size_t n);</span>
00073 <span class="comment"> *       - int    strcasecmp(const char *s1, const char *s2);</span>
00074 <span class="comment"> *       - int    strncasecmp(const char *s1, const char *s2, size_t n);</span>
00075 <span class="comment"> *       - char  *strcat(char *dest, const char *src);</span>
00076 <span class="comment"> *       - char  *strncat(char *dest, const char *src, size_t n);</span>
00077 <span class="comment"> *       - char  *strcpy(char *dest, const char *src);</span>
00078 <span class="comment"> *       - char  *strncpy(char *dest, const char *src, size_t n);</span>
00079 <span class="comment"> *</span>
00080 <span class="comment"> * Rules:</span>
00081 <span class="comment"> *       -# no looking at source to libc, X, kernel, or any other  reimplimented these functions</span>
00082 <span class="comment"> *       -# You may use other headers as needed as long as they themselves don't circularly depend on &lt;string.h&gt;</span>
00083 <span class="comment"> *       -# Entries must be portable.</span>
00084 <span class="comment"> * </span>
00085 <span class="comment"> * \section copyright Copyright (C) 2003 Manoj Srivastava</span>
00086 <span class="comment"> * </span>
00087 <span class="comment"> * This sample implementation of string functions is free software;</span>
00088 <span class="comment"> * you can redistribute it and/or modify it under the terms of the GNU</span>
00089 <span class="comment"> * General Public License as published by the Free Software</span>
00090 <span class="comment"> * Foundation; either version 2, or (at your option) any later</span>
00091 <span class="comment"> * version.</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> * This sample implementation of string functions is distributed in</span>
00094 <span class="comment"> * the hope that it will be useful, but WITHOUT ANY WARRANTY; without</span>
00095 <span class="comment"> * even the implied warranty of MERCHANTABILITY or FITNESS FOR A</span>
00096 <span class="comment"> * PARTICULAR PURPOSE.  See the GNU General Public License for more</span>
00097 <span class="comment"> * details.</span>
00098 <span class="comment"> *</span>
00099 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00100 <span class="comment"> * along with This sample implementation of string functions; see the</span>
00101 <span class="comment"> * file COPYING.  If not, write to the Free Software Foundation, Inc.,</span>
00102 <span class="comment"> * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00103 <span class="comment"> *</span>
00104 <span class="comment"> */</span>
00105 
00106 <span class="keyword">extern</span> <span class="keywordtype">int</span> errno;
00107 
00108 
00109 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00110 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00111 <span class="preprocessor">#include &lt;string.h&gt;</span>
00112 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00113 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00114 
00115 
00116 size_t <a class="code" href="string__test_8c.html#a7">manoj_strlen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
00117 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a8">test_strlen</a>(<span class="keywordtype">void</span>);
00118 
00119 <span class="keywordtype">char</span> * <a class="code" href="string__test_8c.html#a9">manoj_strcpy</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src);
00120 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a10">test_strcpy</a>(<span class="keywordtype">void</span>);
00121 
00122 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a11">manoj_strncpy</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n);
00123 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a12">test_strncpy</a>(<span class="keywordtype">void</span>);
00124 
00125 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a13">manoj_strdup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
00126 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a14">test_strdup</a>(<span class="keywordtype">void</span>);
00127 
00128 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a15">manoj_strcat</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src);
00129 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a16">test_strcat</a>(<span class="keywordtype">void</span>);
00130 
00131 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a17">manoj_strncat</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n);
00132 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a18">test_strncat</a>(<span class="keywordtype">void</span>);
00133 
00134 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a19">manoj_strcmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2);
00135 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a20">test_strcmp</a>(<span class="keywordtype">void</span>);
00136 
00137 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a21">manoj_strncmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t n);
00138 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a22">test_strncmp</a>(<span class="keywordtype">void</span>);
00139 
00140 
00141 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a23">strcasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2);
00142 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a24">manoj_strcasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2);
00143 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a25">test_strcasecmp</a>(<span class="keywordtype">void</span>);
00144 
00145 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a26">strncasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t n);
00146 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a27">manoj_strncasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t n);
00147 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a28">test_strncasecmp</a>(<span class="keywordtype">void</span>);
00148 
00149 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a29">manoj_strchr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c);
00150 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a30">test_strchr</a>(<span class="keywordtype">void</span>);
00151 
00152 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a31">manoj_strrchr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c);
00153 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a32">test_strrchr</a>(<span class="keywordtype">void</span>);
00154 
00155 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a33">manoj_strtok</a>(<span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim);
00156 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a34">test_strtok</a>(<span class="keywordtype">void</span>);
00157 
00158 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a35">strtok_r</a>(<span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim, <span class="keywordtype">char</span> **ptrptr);
00159 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a36">manoj_strtok_r</a>(<span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim, <span class="keywordtype">char</span> **ptrptr);
00160 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a37">test_strtok_r</a>(<span class="keywordtype">void</span>);
00161 
00162 <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a38">manoj_strstr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *haystack, <span class="keyword">const</span> <span class="keywordtype">char</span> *needle);
00163 <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a39">test_strstr</a>(<span class="keywordtype">void</span>);
00164 <span class="comment"></span>
00165 <span class="comment">/**</span>
00166 <span class="comment"> * @brief Begin blocks for macros</span>
00167 <span class="comment"> *</span>
00168 <span class="comment"> * Macros are dangerous if they use an  if--then--else control statement,</span>
00169 <span class="comment"> * because  they may  be  used in  an   if--then--else control  statement</span>
00170 <span class="comment"> * themselsves, and should be enclosed  in the following block to prevent</span>
00171 <span class="comment"> * problems (like dangling else statements).</span>
00172 <span class="comment"> */</span>
<a name="l00173"></a><a class="code" href="string__test_8c.html#a0">00173</a> <span class="preprocessor">#define      BEGIN_BLOCK     do {        </span><span class="comment">/* begin macros with this */</span>
00174 <span class="comment"></span>
00175 <span class="comment">/**</span>
00176 <span class="comment"> * @brief And the corresponding End  block</span>
00177 <span class="comment"> */</span>
<a name="l00178"></a><a class="code" href="string__test_8c.html#a1">00178</a> <span class="preprocessor">#define      END_BLOCK       } while (0) </span><span class="comment">/* end macros with this */</span>
00179 
00180 
00181 <span class="comment"></span>
00182 <span class="comment">/** </span>
00183 <span class="comment"> * @brief 7.21.6.3 The strlen function </span>
00184 <span class="comment"> * @param src_p A pointer to the char array to whose length is  required</span>
00185 <span class="comment"> * @return The strlen() function returns the number of characters in src_p</span>
00186 <span class="comment"> * </span>
00187 <span class="comment"> * The strlen function computes the length of the string pointed to by</span>
00188 <span class="comment"> * src_p. The strlen function returns the number of characters that</span>
00189 <span class="comment"> * precede the null character.</span>
00190 <span class="comment"> */</span>
<a name="l00191"></a><a class="code" href="string__test_8c.html#a7">00191</a> size_t <a class="code" href="string__test_8c.html#a7">manoj_strlen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *src_p)
00192 {
00193   size_t i = 0;
00194   <span class="keywordflow">if</span>(*src_p){ <span class="keywordflow">while</span>(*(src_p++)) i++; } 
00195   <span class="keywordflow">return</span> i;
00196 }
00197 <span class="comment"></span>
00198 <span class="comment">/**</span>
00199 <span class="comment"> * @brief 7.21.2.3 The strcpy function </span>
00200 <span class="comment"> * @param src_p The source string</span>
00201 <span class="comment"> * @param dest_p The destination the source string is copied to</span>
00202 <span class="comment"> * @return The strcpy function returns the value of dest_p.</span>
00203 <span class="comment"> *</span>
00204 <span class="comment"> * The strcpy function copies the string pointed to by src_p (including </span>
00205 <span class="comment"> * the terminating null character) into the array pointed to by dest_p. If</span>
00206 <span class="comment"> * copying takes place between objects that overlap, the behavior is</span>
00207 <span class="comment"> * undefined.  </span>
00208 <span class="comment"> */</span>
<a name="l00209"></a><a class="code" href="string__test_8c.html#a9">00209</a> <span class="keywordtype">char</span> * <a class="code" href="string__test_8c.html#a9">manoj_strcpy</a>(<span class="keywordtype">char</span> *dest_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_p)
00210 {
00211   <span class="keywordtype">char</span> * ret_p = dest_p;
00212   <span class="keywordflow">while</span>(*src_p) *(dest_p++) = *(src_p++);
00213   *dest_p = 0;
00214   <span class="keywordflow">return</span> ret_p;
00215 }
00216 <span class="comment"></span>
00217 <span class="comment">/**</span>
00218 <span class="comment"> * @brief 7.21.2.4 The strncpy function</span>
00219 <span class="comment"> * @param src_p The source string</span>
00220 <span class="comment"> * @param dest_p The destination the source string is copied to</span>
00221 <span class="comment"> * @param n The number of bytes copied</span>
00222 <span class="comment"> * @return The strncpy function returns the value of dest_p.</span>
00223 <span class="comment"> *</span>
00224 <span class="comment"> * The strncpy function copies not more than n characters (characters</span>
00225 <span class="comment"> * that follow a null character are not copied) from the array pointed</span>
00226 <span class="comment"> * to by src_p to the array pointed to by dest_p.  if there is no null</span>
00227 <span class="comment"> * byte among the first n bytes of src_p, the result will not be</span>
00228 <span class="comment"> * null-terminated. </span>
00229 <span class="comment"> *</span>
00230 <span class="comment"> * In the case where the length of src_p is less than that of n, the</span>
00231 <span class="comment"> * remainder of dest_p will be padded with nulls.</span>
00232 <span class="comment"> *</span>
00233 <span class="comment"> */</span>
<a name="l00234"></a><a class="code" href="string__test_8c.html#a11">00234</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a11">manoj_strncpy</a>(<span class="keywordtype">char</span> *dest_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_p, size_t n)
00235 {
00236   <span class="keywordtype">char</span> * ret_p = dest_p;
00237   size_t j = 0;
00238   memset (dest_p, 0, n);
00239   <span class="keywordflow">while</span>(j++ &lt; n &amp;&amp; *src_p) *(dest_p++) = *(src_p++);
00240   <span class="keywordflow">return</span> ret_p;
00241 }
00242 <span class="comment"></span>
00243 <span class="comment">/**</span>
00244 <span class="comment"> * @brief The strdup function</span>
00245 <span class="comment"> * @param src_p The source string</span>
00246 <span class="comment"> * @return The strdup function returns a copy of the input string, or NULL</span>
00247 <span class="comment"> *</span>
00248 <span class="comment"> * This is not an ANSI C standard function, so no reference exists.   </span>
00249 <span class="comment"> * The  strdup()  function  returns  a  pointer to a new string which</span>
00250 <span class="comment"> * is a duplicate of the string src_p.  Memory for the new string is</span>
00251 <span class="comment"> * obtained  with malloc(3), and can be freed with free(3).</span>
00252 <span class="comment"> */</span>
<a name="l00253"></a><a class="code" href="string__test_8c.html#a13">00253</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a13">manoj_strdup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *src_p)
00254 {
00255   <span class="keywordtype">char</span> *dest_p = malloc(strlen(src_p) + 1);
00256   <span class="keywordflow">if</span>(dest_p) (void) strcpy(dest_p, src_p);
00257   <span class="keywordflow">return</span> dest_p;
00258 }
00259 <span class="comment"></span>
00260 <span class="comment">/**</span>
00261 <span class="comment"> * @brief 7.21.3.1 The strcat function </span>
00262 <span class="comment"> * @param src_p The source string</span>
00263 <span class="comment"> * @param dest_p The destination the source string is appended to</span>
00264 <span class="comment"> * @return The strcat function returns the value of dest_p.</span>
00265 <span class="comment"> *</span>
00266 <span class="comment"> * The strcat function appends a copy of the string pointed to by</span>
00267 <span class="comment"> * src_p  (including the terminating null character) to the end of the</span>
00268 <span class="comment"> * string pointed to by dest_p. The initial character of src_p overwrites</span>
00269 <span class="comment"> * the null character at the end of dest_p. If copying takes place between</span>
00270 <span class="comment"> * objects that overlap, the behavior is undefined. </span>
00271 <span class="comment"> *</span>
00272 <span class="comment"> * Memory for the new string is obtained  with malloc(3), and can be</span>
00273 <span class="comment"> * freed with free(3). </span>
00274 <span class="comment"> */</span>
<a name="l00275"></a><a class="code" href="string__test_8c.html#a15">00275</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a15">manoj_strcat</a>(<span class="keywordtype">char</span> *dest_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_p)
00276 {
00277   <span class="keywordtype">char</span> * ret_p = dest_p;
00278   <span class="keywordflow">while</span>(*(dest_p++)) ;
00279   dest_p--;
00280   <span class="keywordflow">while</span>(*src_p) *(dest_p++) = *(src_p++);
00281   *dest_p = 0;
00282   <span class="keywordflow">return</span> ret_p;
00283 }
00284 <span class="comment"></span>
00285 <span class="comment">/**</span>
00286 <span class="comment"> * @brief 7.21.3.2 The strncat function  </span>
00287 <span class="comment"> * @param src_p The source string</span>
00288 <span class="comment"> * @param dest_p The destination the source string is appended to</span>
00289 <span class="comment"> * @param n The number of bytes appended</span>
00290 <span class="comment"> * @return The strncat function returns the value of dest_p.</span>
00291 <span class="comment"> *</span>
00292 <span class="comment"> * The strncat function appends not more than n characters (a null</span>
00293 <span class="comment"> * character and characters that follow it are not appended) from the</span>
00294 <span class="comment"> * array pointed to by  src_p to the end of the string pointed to by</span>
00295 <span class="comment"> * dest_p. The initial character of src_p overwrites the null</span>
00296 <span class="comment"> * character at the end of dest_p. If copying takes place between</span>
00297 <span class="comment"> * objects that overlap, the behavior is undefined. </span>
00298 <span class="comment"> */</span>
<a name="l00299"></a><a class="code" href="string__test_8c.html#a17">00299</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a17">manoj_strncat</a>(<span class="keywordtype">char</span> *dest_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_p, size_t n)
00300 {  
00301   <span class="keywordtype">char</span> * ret_p = dest_p;
00302   size_t j = 0;
00303   <span class="keywordflow">while</span>(*(dest_p++)) ;
00304   dest_p--;
00305   <span class="keywordflow">while</span>(j++ &lt; n &amp;&amp; *src_p) *(dest_p++) = *(src_p++);
00306   <span class="keywordflow">return</span> ret_p;
00307 }
00308 <span class="comment"></span>
00309 <span class="comment">/**</span>
00310 <span class="comment"> * @brief 7.21.4.2 The strcmp function Synopsis</span>
00311 <span class="comment"> * @param s1 The first of two strings to be compared</span>
00312 <span class="comment"> * @param s2 The second of two strings to be compared</span>
00313 <span class="comment"> * @return The strcmp function returns an integer</span>
00314 <span class="comment"> *</span>
00315 <span class="comment"> * The strcmp function compares the string pointed to by s1 to the</span>
00316 <span class="comment"> * string pointed to by s2. The strcmp function returns an integer</span>
00317 <span class="comment"> * greater than, equal to, or less than zero, accordingly as the</span>
00318 <span class="comment"> * string pointed to by s1 is greater than, equal to, or less than the</span>
00319 <span class="comment"> * string s2. </span>
00320 <span class="comment"> */</span>
<a name="l00321"></a><a class="code" href="string__test_8c.html#a19">00321</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a19">manoj_strcmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2)
00322 {
00323   <span class="keywordflow">while</span>(*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2) {s1++; s2++; };
00324   <span class="keywordflow">if</span>(*s1)
00325    {
00326      <span class="keywordflow">if</span>(*s2)
00327       {
00328         <span class="keywordflow">return</span> ((*s1 &lt; *s2) ? -1 : ((*s1 == *s2) ? 0 : 1));
00329       } 
00330      <span class="keywordflow">else</span>       <span class="keywordflow">return</span> 1;       <span class="comment">/* s1 is longer than s2, but identical */</span>
00331    } 
00332   <span class="keywordflow">else</span>
00333    {
00334      <span class="keywordflow">if</span>(*s2) <span class="keywordflow">return</span> -1;         <span class="comment">/* s1 is shorter, and hence less than s2*/</span>
00335      <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;             <span class="comment">/* Both strings are identical*/</span>
00336    }   
00337 }
00338 
00339 <span class="comment"></span>
00340 <span class="comment">/**</span>
00341 <span class="comment"> * @brief 7.21.4.4 The strncmp function Synopsis</span>
00342 <span class="comment"> * @param s1 The first of two strings to be compared</span>
00343 <span class="comment"> * @param s2 The second of two strings to be compared</span>
00344 <span class="comment"> * @param n The number of bytes compared</span>
00345 <span class="comment"> * @return The strncmp function returns an integer</span>
00346 <span class="comment"> *</span>
00347 <span class="comment"> * The strncmp function compares not more than n characters</span>
00348 <span class="comment"> * (characters that follow a null character are not compared) from the</span>
00349 <span class="comment"> * array pointed to by s1 to the array pointed to by s2.  The strncmp</span>
00350 <span class="comment"> * function returns an integer greater than, equal to, or less than</span>
00351 <span class="comment"> * zero,  accordingly as the possibly null-terminated array pointed to</span>
00352 <span class="comment"> * by s1 is greater than, equal to, or less than the possibly</span>
00353 <span class="comment"> * null-terminated array pointed to by s2. </span>
00354 <span class="comment"> */</span>
<a name="l00355"></a><a class="code" href="string__test_8c.html#a21">00355</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a21">manoj_strncmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t n)
00356 {
00357   size_t j = 0;
00358   <span class="keywordflow">if</span>(n &lt;= 0) <span class="keywordflow">return</span> 0;
00359   <span class="keywordflow">while</span>(j++ &lt; n &amp;&amp; *s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2) {s1++; s2++; };
00360   <span class="keywordflow">if</span>(j == n) <span class="keywordflow">return</span> 0;
00361   <span class="keywordflow">if</span>(*s1)
00362    {
00363      <span class="keywordflow">if</span>(*s2)
00364       {
00365         <span class="keywordflow">return</span> ((*s1 &lt; *s2) ? -1 : ((*s1 == *s2) ? 0 : 1));
00366       } 
00367      <span class="keywordflow">else</span>       <span class="keywordflow">return</span> 1;       <span class="comment">/* s1 is longer than s2, but identical */</span>
00368    } 
00369   <span class="keywordflow">else</span>
00370    {
00371      <span class="keywordflow">if</span>(*s2) <span class="keywordflow">return</span> -1;         <span class="comment">/* s1 is shorter, and hence less than s2*/</span>
00372      <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;             <span class="comment">/* Both strings are identical*/</span>
00373    }   
00374 }
00375 <span class="comment"></span>
00376 <span class="comment">/**</span>
00377 <span class="comment"> * @brief The strcasecmp function Synopsis</span>
00378 <span class="comment"> * @param s1 The first of two strings to be compared</span>
00379 <span class="comment"> * @param s2 The second of two strings to be compared</span>
00380 <span class="comment"> * @return The strcasecmp function returns an integer</span>
00381 <span class="comment"> *</span>
00382 <span class="comment"> * This is not an ANSI C function, but a BSD 4.4 extention. </span>
00383 <span class="comment"> * The strcasecmp function compares the string pointed to by s1 to the</span>
00384 <span class="comment"> * string pointed to by s2. The strcasecmp function returns an integer</span>
00385 <span class="comment"> * greater than, equal to, or less than zero, accordingly as the</span>
00386 <span class="comment"> * string pointed to by s1 is greater than, equal to, or less than the</span>
00387 <span class="comment"> * string s2. </span>
00388 <span class="comment"> */</span>
<a name="l00389"></a><a class="code" href="string__test_8c.html#a24">00389</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a24">manoj_strcasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2)
00390 {
00391   <span class="keywordflow">while</span>(*s1 &amp;&amp; *s2 &amp;&amp; toupper(*s1) == toupper(*s2)) {s1++; s2++; };
00392   <span class="keywordflow">if</span>(*s1)
00393    {
00394      <span class="keywordflow">if</span>(*s2)
00395       {
00396         <span class="keywordflow">return</span> ((toupper(*s1) &lt; toupper(*s2)) ? -1 :
00397                 ((toupper(*s1) ==toupper( *s2)) ? 0 : 1));
00398       } 
00399      <span class="keywordflow">else</span>       <span class="keywordflow">return</span> 1;       <span class="comment">/* s1 is longer than s2, but identical */</span>
00400    } 
00401   <span class="keywordflow">else</span>
00402    {
00403      <span class="keywordflow">if</span>(*s2) <span class="keywordflow">return</span> -1;         <span class="comment">/* s1 is shorter, and hence less than s2*/</span>
00404      <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;             <span class="comment">/* Both strings are identical*/</span>
00405    }   
00406 }
00407 
00408 <span class="comment"></span>
00409 <span class="comment">/**</span>
00410 <span class="comment"> * @brief The strncasecmp function Synopsis</span>
00411 <span class="comment"> * @param s1 The first of two strings to be compared</span>
00412 <span class="comment"> * @param s2 The second of two strings to be compared</span>
00413 <span class="comment"> * @param n The number of bytes compared</span>
00414 <span class="comment"> * @return The strncasecmp function returns an integer</span>
00415 <span class="comment"> *</span>
00416 <span class="comment"> * This is not an ANSI C function, but a BSD 4.4 extention. </span>
00417 <span class="comment"> * The strncasecmp function compares not more than n characters</span>
00418 <span class="comment"> * (characters that follow a null character are not compared) from the</span>
00419 <span class="comment"> * array pointed to by s1 to the array pointed to by s2.  The strncasecmp</span>
00420 <span class="comment"> * function returns an integer greater than, equal to, or less than</span>
00421 <span class="comment"> * zero,  accordingly as the possibly null-terminated array pointed to</span>
00422 <span class="comment"> * by s1 is greater than, equal to, or less than the possibly</span>
00423 <span class="comment"> * null-terminated array pointed to by s2. </span>
00424 <span class="comment"> */</span>
<a name="l00425"></a><a class="code" href="string__test_8c.html#a27">00425</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a27">manoj_strncasecmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2, size_t n)
00426 {
00427   size_t j = 0;
00428   <span class="keywordflow">if</span>(n &lt;= 0) <span class="keywordflow">return</span> 0;
00429   <span class="keywordflow">while</span>(j++ &lt; n &amp;&amp; *s1 &amp;&amp; *s2 &amp;&amp; toupper(*s1) == toupper(*s2)) {s1++; s2++; } ;
00430   <span class="keywordflow">if</span>(j == n) <span class="keywordflow">return</span> 0;
00431   <span class="keywordflow">if</span>(*s1)
00432    {
00433      <span class="keywordflow">if</span>(*s2)
00434       {
00435         <span class="keywordflow">return</span> ((toupper(*s1) &lt; toupper(*s2)) ? -1 :
00436                 ((toupper(*s1) ==toupper( *s2)) ? 0 : 1));
00437       } 
00438      <span class="keywordflow">else</span>       <span class="keywordflow">return</span> 1;       <span class="comment">/* s1 is longer than s2, but identical */</span>
00439    } 
00440   <span class="keywordflow">else</span>
00441    {
00442      <span class="keywordflow">if</span>(*s2) <span class="keywordflow">return</span> -1;         <span class="comment">/* s1 is shorter, and hence less than s2*/</span>
00443      <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;             <span class="comment">/* Both strings are identical*/</span>
00444    }   
00445 }
00446 <span class="comment"></span>
00447 <span class="comment">/**</span>
00448 <span class="comment"> * @brief 7.21.5.2 The strchr function </span>
00449 <span class="comment"> * @param str_p The string to search in</span>
00450 <span class="comment"> * @param c The character being searched for.</span>
00451 <span class="comment"> * @return  A pointer to the located charcter, or NULL</span>
00452 <span class="comment"> *</span>
00453 <span class="comment"> * The strchr function locates the first occurrence of c (converted to</span>
00454 <span class="comment"> * a char) in the string pointed to by str_p. The terminating null</span>
00455 <span class="comment"> * character is considered to be part  of the string. The strchr</span>
00456 <span class="comment"> * function returns a pointer to the located character, or a null</span>
00457 <span class="comment"> * pointer if the character does not occur in the string. </span>
00458 <span class="comment"> */</span>
<a name="l00459"></a><a class="code" href="string__test_8c.html#a29">00459</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a29">manoj_strchr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str_p, <span class="keywordtype">int</span> c)
00460 {
00461   <span class="keywordtype">char</span> i = (char) c;
00462   <span class="keywordtype">char</span> * j = (<span class="keywordtype">char</span> *) str_p;    <span class="comment">/* This produces a warning */</span>
00463   <span class="keywordflow">while</span>(*j &amp;&amp; *j != i) j++;
00464   <span class="keywordflow">if</span>(*j) <span class="keywordflow">return</span> j;
00465   <span class="keywordflow">else</span>   <span class="keywordflow">return</span> 0;
00466 }
00467  
00468 <span class="comment"></span>
00469 <span class="comment">/**</span>
00470 <span class="comment"> * @brief 7.21.5.5 The strrchr function </span>
00471 <span class="comment"> * @param str_p The string to search in</span>
00472 <span class="comment"> * @param c The character being searched for.</span>
00473 <span class="comment"> * @return  A pointer to the located charcter, or NULL</span>
00474 <span class="comment"> *</span>
00475 <span class="comment"> * The strrchr function locates the last occurrence of c (converted to</span>
00476 <span class="comment"> * a char) in the string pointed to by str_p. The terminating null</span>
00477 <span class="comment"> * character is considered to be part  of the string. The strchr</span>
00478 <span class="comment"> * function returns a pointer to the located character, or a null</span>
00479 <span class="comment"> * pointer if the character does not occur in the string. </span>
00480 <span class="comment"> */</span>
<a name="l00481"></a><a class="code" href="string__test_8c.html#a31">00481</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a31">manoj_strrchr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str_p, <span class="keywordtype">int</span> c)
00482 {
00483   <span class="keywordtype">char</span> i = (char) c;
00484   <span class="keywordtype">char</span> * j = (<span class="keywordtype">char</span> *) str_p;    <span class="comment">/* This produces a warning */</span>
00485   <span class="keywordflow">while</span>(*(j++));
00486   j--;
00487   <span class="keywordflow">while</span>(j &gt;= str_p &amp;&amp; *j != i) j--;
00488   <span class="keywordflow">if</span>(j &gt; str_p) <span class="keywordflow">return</span> j;
00489   <span class="keywordflow">else</span>
00490    {
00491      <span class="keywordflow">if</span>(*j == i) <span class="keywordflow">return</span> j;
00492      <span class="keywordflow">else</span>        <span class="keywordflow">return</span> 0;
00493    }
00494 }
00495 
00496 <span class="comment">/* </span>
00497 <span class="comment"> * The warning produced in the casts above seem to have no work</span>
00498 <span class="comment"> * arounds; how can these functions return a pointrer to a mutable</span>
00499 <span class="comment"> * string when the input string itself is a const string? This seems</span>
00500 <span class="comment"> * like a defect in the C99 standard.</span>
00501 <span class="comment"> */</span>
00502 
00503 <span class="comment"></span>
00504 <span class="comment">/**</span>
00505 <span class="comment"> * @brief 7.21.5.8 The strtok function</span>
00506 <span class="comment"> * @param str_p The string to be tokenized</span>
00507 <span class="comment"> * @param delim The string conmtaining the list of token separators</span>
00508 <span class="comment"> * @return  The strtok function returns a pointer to the first token, or NULL</span>
00509 <span class="comment"> *</span>
00510 <span class="comment"> * A sequence of calls to the strtok function breaks the string</span>
00511 <span class="comment"> * pointed to by str_p into a sequence of tokens, each of which is</span>
00512 <span class="comment"> * delimited by a character from the string pointed to by delim. The</span>
00513 <span class="comment"> * first call in the sequence has a non-null first argument;</span>
00514 <span class="comment"> * subsequent calls in the sequence have a null first argument.  The</span>
00515 <span class="comment"> * separator string pointed to by delim may be different from call to</span>
00516 <span class="comment"> * call. </span>
00517 <span class="comment"> *</span>
00518 <span class="comment"> * The first call in the sequence searches the string pointed to by</span>
00519 <span class="comment"> * str_p for the first character that is not contained in the current</span>
00520 <span class="comment"> * separator string pointed to by delim. If no such character is</span>
00521 <span class="comment"> * found, then there are no tokens in the string pointed to by s1 and</span>
00522 <span class="comment"> * the strtok function returns a null pointer. If such a character is</span>
00523 <span class="comment"> * found, it is the start of the first token. </span>
00524 <span class="comment"> *</span>
00525 <span class="comment"> * The strtok function then searches from there for a character that</span>
00526 <span class="comment"> * is contained in the current separator string. If no such character</span>
00527 <span class="comment"> * is found, the current token extends to the end of the string</span>
00528 <span class="comment"> * pointed to by s1, and subsequent searches for a token will return a</span>
00529 <span class="comment"> * null pointer. If such a character is found, it is overwritten by a</span>
00530 <span class="comment"> * null character, which terminates the current token. The strtok</span>
00531 <span class="comment"> * function saves a pointer to the following character, from which the</span>
00532 <span class="comment"> * next search for a token will start. </span>
00533 <span class="comment"> *</span>
00534 <span class="comment"> * Each subsequent call, with a null pointer as the value of the first</span>
00535 <span class="comment"> * argument, starts searching from the saved pointer and behaves as</span>
00536 <span class="comment"> * described above. </span>
00537 <span class="comment"> *</span>
00538 <span class="comment"> * The implementation shall behave as if no library function calls the</span>
00539 <span class="comment"> * strtok function. </span>
00540 <span class="comment"> *</span>
00541 <span class="comment"> * The strtok function returns a pointer to the first character of a</span>
00542 <span class="comment"> * token, or a null pointer if there is no token.</span>
00543 <span class="comment"> *</span>
00544 <span class="comment"> * This function modifies its first argument. The strtok() function</span>
00545 <span class="comment"> * uses a static  buffer  while  parsing,  so it's not thread</span>
00546 <span class="comment"> * safe. The strtok() function  cannot be used on constant strings.</span>
00547 <span class="comment"> */</span>
<a name="l00548"></a><a class="code" href="string__test_8c.html#a33">00548</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a33">manoj_strtok</a>(<span class="keywordtype">char</span> *str_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim)
00549 {
00550   <span class="keyword">static</span> <span class="keywordtype">char</span> * index_p;
00551   <span class="keywordtype">int</span> i = 0;
00552   <span class="keywordtype">int</span> j = 0;
00553   <span class="keywordtype">int</span> k = 0;
00554   <span class="keywordtype">int</span> l = 0;
00555   
00556   <span class="keywordflow">if</span>(! delim) <span class="keywordflow">return</span> 0;
00557   <span class="keywordflow">if</span>(str_p)  index_p = str_p;   <span class="comment">/* initialize, since a new string is given*/</span>
00558   <span class="keywordflow">if</span>(! index_p) <span class="keywordflow">return</span> 0;
00559 
00560   j = strlen(delim);
00561   k = strlen(index_p);
00562 
00563   <span class="comment">/* Skip over initial matches */</span>
00564   <span class="keywordflow">for</span>(l = 0; l &lt; k; l++)
00565    {
00566      <span class="keywordflow">if</span>(strchr(delim, index_p[l])) <span class="keywordflow">continue</span>;
00567      index_p = index_p + l;
00568      <span class="keywordflow">break</span>;
00569    }
00570 
00571 
00572   <span class="keywordflow">for</span>(l = 0; l &lt; k; l++)
00573    {
00574      <span class="keywordflow">for</span>(i = 0; i &lt; j; i++)
00575       {
00576         <span class="keywordflow">if</span>(index_p[l] == delim[i])
00577          {
00578            <span class="keywordtype">char</span> *retval_p = index_p;
00579            index_p[l] = 0;
00580            index_p = index_p + l +1;
00581            <span class="keywordflow">return</span> retval_p;
00582          }
00583       }
00584    }
00585   <span class="keywordflow">return</span> 0;                     <span class="comment">/* found noyhing */</span>
00586 }
00587 <span class="comment"></span>
00588 <span class="comment">/**</span>
00589 <span class="comment"> * @brief The strtok_r function</span>
00590 <span class="comment"> * @param str_p The string to be tokenized</span>
00591 <span class="comment"> * @param delim The string conmtaining the list of token separators</span>
00592 <span class="comment"> * @param ptrptr Pointer to a user allocated buffer </span>
00593 <span class="comment"> * @return  The strtok function returns a pointer to the first token, or NULL</span>
00594 <span class="comment"> *</span>
00595 <span class="comment"> * This is a POSIX extention, and is not a ANSI C function.</span>
00596 <span class="comment"> * The  strtok_r()  function  is a reentrant version of the strtok()</span>
00597 <span class="comment"> * function, which instead of using its own static buffer, requires a</span>
00598 <span class="comment"> * pointer to  a user allocated char*. This pointer, the ptrptr</span>
00599 <span class="comment"> * parameter, must be the same while parsing the same string. </span>
00600 <span class="comment"> *</span>
00601 <span class="comment"> * This function modifies its first argument, and cannot be used on</span>
00602 <span class="comment"> * constant strings. </span>
00603 <span class="comment"> */</span>
<a name="l00604"></a><a class="code" href="string__test_8c.html#a36">00604</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a36">manoj_strtok_r</a>(<span class="keywordtype">char</span> *str_p, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim, <span class="keywordtype">char</span> **ptrptr)
00605 {
00606   <span class="keywordtype">char</span> * index_p;
00607   <span class="keywordtype">int</span> i = 0;
00608   <span class="keywordtype">int</span> j = 0;
00609   <span class="keywordtype">int</span> k = 0;
00610   <span class="keywordtype">int</span> l = 0;
00611 
00612   <span class="keywordflow">if</span>(! delim) <span class="keywordflow">return</span> 0;
00613   <span class="keywordflow">if</span>(str_p)  (void) strcpy (*ptrptr, str_p);
00614   index_p = *ptrptr;    
00615   <span class="keywordflow">if</span>(! index_p) <span class="keywordflow">return</span> 0;
00616 
00617   j = strlen(delim);  
00618   k = strlen(index_p);
00619   <span class="comment">/* Skip over initial matches */</span>
00620   <span class="keywordflow">for</span>(l = 0; l &lt; k; l++)
00621    {
00622      <span class="keywordflow">if</span>(strchr(delim, index_p[l])) <span class="keywordflow">continue</span>;
00623      index_p = index_p + l;
00624      <span class="keywordflow">break</span>;
00625    }
00626 
00627   <span class="keywordflow">for</span>(l = 0; l &lt; k; l++)
00628    {
00629      <span class="keywordflow">for</span>(i = 0; i &lt; j; i++)
00630       {
00631         <span class="keywordflow">if</span>(index_p[l] == delim[i])
00632          {
00633            <span class="keywordtype">char</span> *retval_p = index_p;
00634            index_p[l] = 0;
00635            *ptrptr = index_p + l +1 ;
00636            <span class="keywordflow">return</span> retval_p;
00637          }
00638       }
00639    }
00640   <span class="keywordflow">return</span> 0;                     <span class="comment">/* found noyhing */</span>
00641 }
00642 <span class="comment"></span>
00643 <span class="comment">/**</span>
00644 <span class="comment"> * @brief The size of the alphabet -- which happens to be the ascii namespace</span>
00645 <span class="comment"> */</span>
<a name="l00646"></a><a class="code" href="string__test_8c.html#a2">00646</a> <span class="preprocessor">#define ASIZE 256</span>
00647 <span class="preprocessor"></span>
00648 <span class="comment"></span>
00649 <span class="comment">/**</span>
00650 <span class="comment"> * @brief 7.21.5.7 The strstr function</span>
00651 <span class="comment"> * @param haystack The string space to search in</span>
00652 <span class="comment"> * @param needle The string to search for</span>
00653 <span class="comment"> * @return The strstr function returns a pointer to the located string, or NULL</span>
00654 <span class="comment"> *</span>
00655 <span class="comment"> * The strstr function locates the first occurrence in the string</span>
00656 <span class="comment"> * pointed to by haystack of the sequence of characters (excluding</span>
00657 <span class="comment"> * the terminating null character) in the string pointed to by</span>
00658 <span class="comment"> * needle. </span>
00659 <span class="comment"></span>
00660 <span class="comment"> * The strstr function returns a pointer to the located string, or a</span>
00661 <span class="comment"> * null pointer if the string is not found. If needle points to a string</span>
00662 <span class="comment"> * with zero length, the function returns haystack. </span>
00663 <span class="comment"> *</span>
00664 <span class="comment"> * This implementation uses the Boyer-Moore algorithm. This algorithm</span>
00665 <span class="comment"> * searches for the pattern in a window that slides along the string</span>
00666 <span class="comment"> * to be searched. It is as if we have opened a window on the text to</span>
00667 <span class="comment"> * allow us to see only pat_lenght characters. Later, the window is</span>
00668 <span class="comment"> * slid to the right, allowing us to view other positions. The text of</span>
00669 <span class="comment"> * the pattern is ompared to the text exposed in the window, in a right to</span>
00670 <span class="comment"> * left order. In case of a mimatch, the window is slid over and the</span>
00671 <span class="comment"> * match restarted. The value of Boyer-Moore is that the window is</span>
00672 <span class="comment"> * slid over by more than one character (which is what the brute</span>
00673 <span class="comment"> * force method does), and this improes the efficiency of the</span>
00674 <span class="comment"> * algorithm, since we do not look at unfeasible positions to start</span>
00675 <span class="comment"> * matching. The amount by which we slide the window over is the</span>
00676 <span class="comment"> * maximum safe value (we do not want to slide the window too far, in</span>
00677 <span class="comment"> * case we miss a match. </span>
00678 <span class="comment"> *</span>
00679 <span class="comment"> * How much we can skip is determined by thte following hueristics:</span>
00680 <span class="comment"> *   -# The bad character rule: looking just at the character that didn't match</span>
00681 <span class="comment"> *   -# The Good suffix rule: Looking at the suffix matched so far</span>
00682 <span class="comment"> */</span>
<a name="l00683"></a><a class="code" href="string__test_8c.html#a38">00683</a> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a38">manoj_strstr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *haystack, <span class="keyword">const</span> <span class="keywordtype">char</span> *needle)
00684 {
00685   <span class="keywordtype">int</span> skip[ASIZE];
00686   <span class="keywordtype">int</span> *shift = 0;
00687   <span class="keywordtype">int</span> *suffix_length = 0;
00688   
00689   <span class="keywordtype">int</span> i = 0;
00690   <span class="keywordtype">int</span> j = 0;
00691   size_t right_end = 0;
00692   <span class="keywordtype">int</span> needle_len = strlen(needle);
00693   <span class="comment">/*</span>
00694 <span class="comment">   * If needle[needle_len - 1] does not exist elsewhere in needle,</span>
00695 <span class="comment">   * then shift by needle_len</span>
00696 <span class="comment">   */</span> 
00697 
00698   <span class="keywordflow">if</span>(!needle) <span class="keywordflow">return</span> 0;
00699 <span class="comment"></span>
00700 <span class="comment">  /**</span>
00701 <span class="comment">   * The bad character rule. </span>
00702 <span class="comment">   *</span>
00703 <span class="comment">   * Look at the character in the window that is being compared at</span>
00704 <span class="comment">   * the moment. In case of a mismatch, if the character does not occur</span>
00705 <span class="comment">   * in the search pattern at all, then there is no possibility that</span>
00706 <span class="comment">   * that character can be part of a match, and any instance of the</span>
00707 <span class="comment">   * pattern in the text must start to the right of the mismatched</span>
00708 <span class="comment">   * character, so the whole window can be slid over just beyond</span>
00709 <span class="comment">   * the character. (In other words, any orientation of the window that</span>
00710 <span class="comment">   * spans the mismatched charactercan't result in a match). So, if we </span>
00711 <span class="comment">   * had already matched m charactrers from the right hand side of </span>
00712 <span class="comment">   * the window, the window slides patlenght - m steps in this case.</span>
00713 <span class="comment">   *</span>
00714 <span class="comment">   *  - Observation 1: If char in the window is known not to occur in</span>
00715 <span class="comment">   *    the pattern, then there is no need to consider the</span>
00716 <span class="comment">   *    possibility of the pattern occuring anywhere bedore the</span>
00717 <span class="comment">   *    current char. If we had already matched d chars, the window</span>
00718 <span class="comment">   *    shifts by patlen -d characters.</span>
00719 <span class="comment">   *</span>
00720 <span class="comment">   * If the mismatched character does occur in the pattern, we need</span>
00721 <span class="comment">   * to slide the window over until the character in the pattern</span>
00722 <span class="comment">   * matches the character in the string. If the character occuers</span>
00723 <span class="comment">   * multiple times in the pattern, we need to slide the rightmost</span>
00724 <span class="comment">   * occurance of the character over the text in the string; however,</span>
00725 <span class="comment">   * sometimes that means sliding the window backwards, which we know</span>
00726 <span class="comment">   * can't be right. So at the very least, the minimum skip is at</span>
00727 <span class="comment">   * least one charactrer.</span>
00728 <span class="comment">   *</span>
00729 <span class="comment">   *  - Observation 2: If the rightmost occurrence of the character</span>
00730 <span class="comment">   *    being tested is d characters from the rightmost character in</span>
00731 <span class="comment">   *    the pattern, then we can slide down d characters without</span>
00732 <span class="comment">   *    looking for matches, to align the character in the text and</span>
00733 <span class="comment">   *    in the pattern. If we slide any less than d, the characters</span>
00734 <span class="comment">   *    won't match.(We need to allow for any characters already</span>
00735 <span class="comment">   *    matched when we slide the window, since what we really are</span>
00736 <span class="comment">   *    doing is to align the characters). </span>
00737 <span class="comment">   *</span>
00738 <span class="comment">   * Uses knowledge of one character in the text, the character that</span>
00739 <span class="comment">   * is current;ly being examined. </span>
00740 <span class="comment">   */</span>
00741 
00742   <span class="comment">/* </span>
00743 <span class="comment">   * initialize the skip table. Chars not in the pattern slide all</span>
00744 <span class="comment">   * the way forward.</span>
00745 <span class="comment">   */</span>
00746   <span class="keywordflow">for</span>(i = 0; i &lt; ASIZE; i++) skip[i] = needle_len;
00747   <span class="comment">/*</span>
00748 <span class="comment">   * Now for chars that are in the key Need to fill from left to</span>
00749 <span class="comment">   * right</span>
00750 <span class="comment">   */</span>
00751   <span class="keywordflow">for</span>(i = 0; i &lt; needle_len - 1; i++) 
00752     skip[ (int) needle[i] ] = needle_len -i -1;<span class="comment"></span>
00753 <span class="comment">  /**</span>
00754 <span class="comment">   * The Good Suffix Hueristic</span>
00755 <span class="comment">   *</span>
00756 <span class="comment">   * This hueristic applies for patterns with repeating strings. The</span>
00757 <span class="comment">   * bad charcter  hueristic shall also work for patterns with</span>
00758 <span class="comment">   * repeating subpatterns, but the search will not be as eficient as</span>
00759 <span class="comment">   * possible. By examining partial matches and repeats in the search</span>
00760 <span class="comment">   * pattern, it is possible to make more drastic shifts in the</span>
00761 <span class="comment">   * window and match more rapidly. This hueristic represents the</span>
00762 <span class="comment">   * largest skip which can be made until the characters that have</span>
00763 <span class="comment">   * been matched coincide with another sequence in the</span>
00764 <span class="comment">   * pattern. Thus, we use our knowledge of a substring that exists</span>
00765 <span class="comment">   * in the text to help determine the safe shift. Any new position</span>
00766 <span class="comment">   * of the pattern that overlaps the current postion in the text</span>
00767 <span class="comment">   * _must_ match the characters we already know exist at this</span>
00768 <span class="comment">   * location (since we have matched them), since otherwise a</span>
00769 <span class="comment">   * mismatch is inevitable. In addition, the character that caused a</span>
00770 <span class="comment">   * mismatch right now must match its counterpart in the pattern in</span>
00771 <span class="comment">   * the new shift, or else the same mimatch would occur again. </span>
00772 <span class="comment">   *</span>
00773 <span class="comment">   * The amount we shift is the lenght of the longest suffix of the</span>
00774 <span class="comment">     matched pattern that matches a prefix of the pattern. </span>
00775 <span class="comment">   */</span>
00776 
00777   <span class="comment">/* suffixes[i]=k s.t. x[i-k+1,...,i]=x[m-k,...,m-1] */</span>
00778 
00779   shift = (<span class="keywordtype">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * (needle_len + 1));
00780   <span class="keywordflow">if</span>(!shift)
00781    {
00782      <a class="code" href="string__test_8c.html#a5">errno</a> = ENOMEM;
00783      <span class="keywordflow">return</span> 0;
00784    } 
00785   suffix_length = (<span class="keywordtype">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * (needle_len + 1));
00786   <span class="keywordflow">if</span>(!suffix_length)
00787    {
00788      <a class="code" href="string__test_8c.html#a5">errno</a> = ENOMEM;
00789      <span class="keywordflow">return</span> 0;
00790    } 
00791   
00792   <span class="comment">/* </span>
00793 <span class="comment">   * Set suffix_length[i] = number of characters right ended at needle[i]</span>
00794 <span class="comment">   * which match the characters right ended at needle[needle_len - 1].</span>
00795 <span class="comment">   */</span>
00796   <span class="keywordflow">for</span> (i = 1; i &lt; needle_len; i++){ 
00797     <span class="keywordflow">for</span> (j = 0; 
00798          j &lt;= i &amp;&amp; needle[needle_len - 1 - j] == needle[i - j];
00799          j++);
00800     suffix_length[i] = j;
00801 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00802 <span class="preprocessor"></span>    fprintf(stderr, <span class="stringliteral">"suffix_length[i(%2d)] = %2d %c\n"</span>, i, j, needle[i]);
00803     <span class="keywordflow">if</span>(j)
00804      {
00805        <span class="keywordtype">int</span> k = 0;
00806        fprintf(stderr, <span class="stringliteral">"%s\n"</span>, needle);
00807        <span class="keywordflow">for</span>(k = 0; k &lt;= needle_len - 1 -j; k++)
00808         {
00809           fprintf(stderr, <span class="stringliteral">" "</span>);
00810         } <span class="comment">/* end of for(k = 0; k &lt; j; k++) */</span>
00811        <span class="keywordflow">for</span>(k = needle_len - 1 - j; k &lt; needle_len - 1; k++)
00812         {
00813           fprintf(stderr, <span class="stringliteral">"|"</span>);
00814         } <span class="comment">/* end of for(k = 0; k &lt; j; k++) */</span>
00815        fprintf(stderr, <span class="stringliteral">"\n"</span>);
00816        <span class="keywordflow">for</span>(k = 0; k &lt;= i -j; k++)
00817         {
00818           fprintf(stderr, <span class="stringliteral">" "</span>);
00819         } <span class="comment">/* end of for(k = 0; k &lt; j; k++) */</span>
00820        <span class="keywordflow">for</span>(k = i - j; k &lt; i; k++)
00821         {
00822           fprintf(stderr, <span class="stringliteral">"^"</span>);
00823         } <span class="comment">/* end of for(k = 0; k &lt; j; k++) */</span>
00824        fprintf(stderr, <span class="stringliteral">"\n"</span>);
00825      } <span class="comment">/* end of if(j) */</span>
00826 <span class="preprocessor">#endif</span>
00827 <span class="preprocessor"></span>  }
00828   <span class="comment">/* Zero the relevant section of the array */</span>
00829   <span class="keywordflow">for</span> (i = 1; i &lt; needle_len; i++) shift[i] = 0;
00830   <span class="comment">/* </span>
00831 <span class="comment">   * Fix up by shifting to the rightmost occurrence of the matched</span>
00832 <span class="comment">   * chars. Note that suffix_length[i] is the length of the suffix</span>
00833 <span class="comment">   * matched at the point i in the pattern. So, when we have matched a</span>
00834 <span class="comment">   * suffix of length suffix_length[i], a similar string is at</span>
00835 <span class="comment">   * position i, and we need to shift the string by needle_len - 1 - i</span>
00836 <span class="comment">   * to bring that other substring under tecurrently matched string. </span>
00837 <span class="comment">   */</span>
00838   <span class="keywordflow">for</span> (i = 0; i &lt;  needle_len; i++)
00839    {
00840      shift[suffix_length[i]] = needle_len - 1 - i;
00841 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00842 <span class="preprocessor"></span>     fprintf(stderr, <span class="stringliteral">"shift[suffix_length[i](%2d)] = i(%2d);\n"</span>,
00843              suffix_length[i], i);
00844 <span class="preprocessor">#endif</span>
00845 <span class="preprocessor"></span>   }
00846 
00847   <span class="comment">/* Let the skip array take care of the case for zero matches */</span>
00848   shift[0] = 1;
00849   <span class="comment">/* </span>
00850 <span class="comment">   * Fix up by considering matches that would run off the end of the</span>
00851 <span class="comment">   * pattern. So, things where the substring was not found, we shift</span>
00852 <span class="comment">   * enough to move the window beyond the matched pattern, but no</span>
00853 <span class="comment">   * more (let the minimum shift be at least 1). </span>
00854 <span class="comment">   */</span>
00855   <span class="keywordflow">for</span> (i = 1; i &lt; needle_len; i++)
00856     {
00857       <span class="keywordflow">if</span> (shift[i] == 0)
00858        {
00859          shift[i] = (needle_len - 1 - i &gt; 1) ?
00860                     needle_len - 1 - i : 1;
00861 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00862 <span class="preprocessor"></span>         fprintf(stderr, <span class="stringliteral">"shift[i(%2d)] = max_gap(%2d);\n"</span>,
00863              i, shift[i]);
00864 <span class="preprocessor">#endif</span>
00865 <span class="preprocessor"></span>       }
00866     }
00867 
00868 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00869 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i = 0; i &lt; needle_len; i++){ 
00870     fprintf(stderr, <span class="stringliteral">"%2d %3c %3d %3d\n"</span>, i, needle[i],
00871             suffix_length[i], shift[i]);
00872   }
00873 <span class="preprocessor">#endif</span>
00874 <span class="preprocessor"></span>
00875   right_end = needle_len -1;
00876   <span class="keywordflow">while</span>(right_end &lt; strlen(haystack))
00877    {
00878      <span class="keywordtype">int</span> sk = 0;
00879      <span class="keywordtype">int</span> sh = 0;
00880 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00881 <span class="preprocessor"></span>     fprintf(stderr, <span class="stringliteral">"\n%s\n"</span>, haystack);
00882      <span class="keywordflow">for</span>(i = 0; i &lt; right_end - needle_len + 1; i++)
00883       {
00884         fprintf(stderr, <span class="stringliteral">" "</span>);
00885       } <span class="comment">/* end of for(i = 0; i &lt; right_end - needle_len + 1; i++) */</span>
00886      fprintf(stderr, <span class="stringliteral">"%s\n"</span>, needle);
00887 <span class="preprocessor">#endif</span>
00888 <span class="preprocessor"></span>
00889      <span class="keywordflow">for</span>(i = 0; 
00890          i &lt; needle_len &amp;&amp; haystack[right_end - i] == needle[needle_len -1 -i];
00891          i++);
00892      <span class="keywordflow">if</span>(i == needle_len)
00893       {
00894 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00895 <span class="preprocessor"></span>        fprintf(stderr, <span class="stringliteral">"Found at %d\n"</span>, right_end - needle_len + 1);
00896 <span class="preprocessor">#endif</span>
00897 <span class="preprocessor"></span>        <span class="keywordflow">return</span> haystack + right_end - needle_len + 1;
00898       } <span class="comment">/* end of if(i == needle_len) */</span>
00899 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00900 <span class="preprocessor"></span>     <span class="keywordflow">for</span>(j = 0; j &lt; right_end - i; j++)
00901       {
00902         fprintf(stderr, <span class="stringliteral">" "</span>);
00903       } <span class="comment">/* end of for(i = 0; i &lt; right_end - needle_len + 1; i++) */</span>
00904      fprintf(stderr, <span class="stringliteral">"|\n"</span>);
00905      
00906      fprintf(stderr, 
00907              <span class="stringliteral">"Mismatch at %d == haystack[%d]=%c != needle[%d]=%c\n"</span>,
00908              right_end - i, right_end - i, haystack[right_end - i], 
00909              needle_len -1 -i, needle[needle_len -1 -i]);
00910 <span class="preprocessor">#endif</span>
00911 <span class="preprocessor"></span>
00912      sk = skip[(int)haystack[right_end - i]];
00913      sh = shift[i];
00914      right_end = (right_end - i + sk &gt; right_end + sh) ?
00915                  right_end - i + sk : right_end + sh;
00916 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00917 <span class="preprocessor"></span>     <span class="keywordflow">if</span>(sk &gt; sh)
00918       {
00919         fprintf(stderr, <span class="stringliteral">"Using skip table to shift by  %d\n"</span>,
00920                 sk);
00921       } <span class="comment">/* end of if(sk &gt; sh) */</span>
00922      <span class="keywordflow">else</span>
00923       {
00924         fprintf(stderr, <span class="stringliteral">"Using shift table to shift by  %d\n"</span>,
00925                 sh);
00926       } <span class="comment">/* end of else */</span>
00927 <span class="preprocessor">#endif     </span>
00928 <span class="preprocessor"></span>   } <span class="comment">/* end of while(right_end &lt; strlen(haystack)) */</span>
00929 <span class="preprocessor">#ifdef LIB_DEBUG</span>
00930 <span class="preprocessor"></span>  fprintf(stderr, <span class="stringliteral">"NOT Found\n"</span>);
00931 <span class="preprocessor">#endif</span>
00932 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
00933 }
00934 
00935 
00936 <span class="comment">/*</span>
00937 <span class="comment"> ####################################################################</span>
00938 <span class="comment"> ####################################################################</span>
00939 <span class="comment"> ####################################################################</span>
00940 <span class="comment"> */</span>
00941 <span class="comment"></span>
00942 <span class="comment">/** </span>
00943 <span class="comment"> * @brief A set of test strings used for regression testing</span>
00944 <span class="comment"> * </span>
00945 <span class="comment"> */</span>
<a name="l00946"></a><a class="code" href="string__test_8c.html#a6">00946</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[] = 
00947   {
00948    <span class="stringliteral">"This ia a longish text string, but not that long, at that"</span>,
00949    <span class="stringliteral">"The long jump \0 and some trailing text at-that"</span>,
00950    <span class="stringliteral">""</span>,
00951    <span class="stringliteral">"Some more test strings"</span>,
00952    <span class="stringliteral">"Yet another one"</span>,
00953    <span class="stringliteral">"what-finally-stops--at-at-that point"</span>, 
00954    <span class="stringliteral">"aksdy923492p4  p39475 q0349750[q3hf30q79340 320496t034 03q495609324uy509y"</span>,
00955    <span class="stringliteral">"character is considered to be part of the string. The chr at-that point"</span>,
00956    0
00957   };
00958 
00959 <span class="comment"></span>
00960 <span class="comment">/**</span>
00961 <span class="comment"> * @brief Test the manoj_strlen function</span>
00962 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
00963 <span class="comment"> */</span>
<a name="l00964"></a><a class="code" href="string__test_8c.html#a8">00964</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a8">test_strlen</a>(<span class="keywordtype">void</span>)
00965 {
00966   <span class="keywordtype">int</span> retval = 0;
00967   <span class="keywordtype">int</span> i;
00968 
00969 <span class="preprocessor">#ifdef DEBUG</span>
00970 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strlen - "</span>); 
00971 <span class="preprocessor">#endif</span>
00972 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
00973    {
00974      <span class="keywordflow">if</span>(strlen(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]) != <a class="code" href="string__test_8c.html#a7">manoj_strlen</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]))
00975       {
00976         retval--;
00977         fprintf (stderr, 
00978                  <span class="stringliteral">"ERROR: manoj_strlen Failed test %d. Got %d, expected %d\n"</span>,
00979                  i, <a class="code" href="string__test_8c.html#a7">manoj_strlen</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]),
00980                  strlen(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]));
00981       }
00982 <span class="preprocessor">#ifdef DEBUG</span>
00983 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
00984       {
00985         fprintf (stderr, <span class="stringliteral">"."</span>);
00986       } <span class="comment">/* end of else */</span>
00987 <span class="preprocessor">#endif     </span>
00988 <span class="preprocessor"></span>   } 
00989 <span class="preprocessor">#ifdef DEBUG</span>
00990 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
00991 <span class="preprocessor">#endif     </span>
00992 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
00993 }
00994 <span class="comment"></span>
00995 <span class="comment">/**</span>
00996 <span class="comment"> * @brief Test the manoj_strcpy function</span>
00997 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
00998 <span class="comment"> *</span>
00999 <span class="comment"> */</span>
<a name="l01000"></a><a class="code" href="string__test_8c.html#a10">01000</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a10">test_strcpy</a>(<span class="keywordtype">void</span>)
01001 {
01002   <span class="keywordtype">int</span> retval = 0;
01003   <span class="keywordtype">char</span> buffer[1024];
01004   <span class="keywordtype">int</span> i = 0;
01005 
01006 <span class="preprocessor">#ifdef DEBUG</span>
01007 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strcpy - "</span>); 
01008 <span class="preprocessor">#endif</span>
01009 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01010    {
01011      <span class="keywordtype">char</span> * orig = 0;
01012      memset(buffer,0,1024);
01013      orig = <a class="code" href="string__test_8c.html#a9">manoj_strcpy</a>(buffer, <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01014      <span class="keywordflow">if</span>(strcmp(orig,<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]))
01015       {
01016         retval--;
01017         fprintf (stderr, 
01018                  <span class="stringliteral">"ERROR: manoj_strcpy Failed test %d. \n"</span>,
01019                  i);
01020       } 
01021 <span class="preprocessor">#ifdef DEBUG</span>
01022 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01023       {
01024         fprintf (stderr, <span class="stringliteral">"."</span>);
01025       } <span class="comment">/* end of else */</span>
01026 <span class="preprocessor">#endif     </span>
01027 <span class="preprocessor"></span>   }
01028 <span class="preprocessor">#ifdef DEBUG</span>
01029 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01030 <span class="preprocessor">#endif  </span>
01031 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01032 }
01033 <span class="comment"></span>
01034 <span class="comment">/**</span>
01035 <span class="comment"> * @brief Test the manoj_strncpy function</span>
01036 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01037 <span class="comment"> *</span>
01038 <span class="comment"> */</span>
<a name="l01039"></a><a class="code" href="string__test_8c.html#a12">01039</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a12">test_strncpy</a>(<span class="keywordtype">void</span>)
01040 {
01041   <span class="keywordtype">int</span> retval = 0;
01042   <span class="keywordtype">char</span> buffer[1024];
01043   <span class="keywordtype">char</span> copy[1024];
01044   <span class="keywordtype">int</span> i = 0;
01045 
01046 <span class="preprocessor">#ifdef DEBUG</span>
01047 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strncpy - "</span>); 
01048 <span class="preprocessor">#endif</span>
01049 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01050    {
01051      <span class="keywordtype">char</span> * orig  = 0;
01052      <span class="keywordtype">char</span> * dummy = 0;
01053      memset(buffer,0,1024);
01054      memset(copy,0,1024);
01055      orig  = <a class="code" href="string__test_8c.html#a11">manoj_strncpy</a>(buffer, <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], 5);
01056      dummy =       strncpy(copy,   <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], 5);
01057      <span class="keywordflow">if</span>(strcmp(orig,dummy))
01058       {
01059         retval--;
01060         fprintf (stderr, 
01061                  <span class="stringliteral">"ERROR: manoj_strncpy Failed test %d. \n"</span>,
01062                  i);
01063       } 
01064 <span class="preprocessor">#ifdef DEBUG</span>
01065 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01066       {
01067         fprintf (stderr, <span class="stringliteral">"."</span>);
01068       } <span class="comment">/* end of else */</span>
01069 <span class="preprocessor">#endif     </span>
01070 <span class="preprocessor"></span>   }
01071 <span class="preprocessor">#ifdef DEBUG</span>
01072 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01073 <span class="preprocessor">#endif  </span>
01074 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01075 }
01076 <span class="comment"></span>
01077 <span class="comment">/**</span>
01078 <span class="comment"> * @brief Test the manoj_strdup function</span>
01079 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01080 <span class="comment"> *</span>
01081 <span class="comment"> */</span>
<a name="l01082"></a><a class="code" href="string__test_8c.html#a14">01082</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a14">test_strdup</a>(<span class="keywordtype">void</span>)
01083 {
01084   <span class="keywordtype">int</span> retval = 0;
01085   <span class="keywordtype">int</span> i = 0;
01086 
01087 <span class="preprocessor">#ifdef DEBUG</span>
01088 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strdup - "</span>); 
01089 <span class="preprocessor">#endif</span>
01090 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01091    {
01092      <span class="keywordtype">char</span> * orig = 0;
01093      orig = <a class="code" href="string__test_8c.html#a13">manoj_strdup</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01094      <span class="keywordflow">if</span>(orig)
01095       {
01096         <span class="keywordflow">if</span>(strcmp(orig,<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]))
01097           {
01098             retval--;
01099             fprintf (stderr, 
01100                      <span class="stringliteral">"ERROR: manoj_strdup Failed test %d. \n"</span>,
01101                      i);
01102           } 
01103         free(orig);
01104       } 
01105      <span class="keywordflow">else</span>
01106       {
01107         fprintf (stderr, 
01108                  <span class="stringliteral">"ERROR: manoj_strdup Failed test %d -- failed malloc\n"</span>,
01109                  i);
01110       }
01111 <span class="preprocessor">#ifdef DEBUG</span>
01112 <span class="preprocessor"></span>     fprintf (stderr, <span class="stringliteral">"."</span>);
01113 <span class="preprocessor">#endif     </span>
01114 <span class="preprocessor"></span>   }
01115 <span class="preprocessor">#ifdef DEBUG</span>
01116 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01117 <span class="preprocessor">#endif  </span>
01118 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01119 }
01120 
01121 
01122 <span class="comment"></span>
01123 <span class="comment">/**</span>
01124 <span class="comment"> * @brief Test the manoj_strcat function</span>
01125 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01126 <span class="comment"> *</span>
01127 <span class="comment"> */</span>
<a name="l01128"></a><a class="code" href="string__test_8c.html#a16">01128</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a16">test_strcat</a>(<span class="keywordtype">void</span>)
01129 {
01130   <span class="keywordtype">int</span> retval = 0;
01131   <span class="keywordtype">char</span> buffer[1024];
01132   <span class="keywordtype">char</span> copy[1024];
01133   <span class="keywordtype">int</span> i = 0;
01134 
01135 <span class="preprocessor">#ifdef DEBUG</span>
01136 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strcat - "</span>); 
01137 <span class="preprocessor">#endif</span>
01138 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01139    {
01140      <span class="keywordtype">char</span> * orig = 0;
01141      <span class="keywordtype">char</span> * dummy = 0;
01142      memset(buffer,0,1024);
01143      memset(copy,0,1024);
01144      (void) strcpy(buffer, <span class="stringliteral">"Original String "</span>);
01145      (void) strcpy(copy,   <span class="stringliteral">"Original String "</span>);
01146      orig  = <a class="code" href="string__test_8c.html#a15">manoj_strcat</a>(buffer, <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01147      dummy =       strcat(copy,   <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01148      <span class="keywordflow">if</span>(strcmp(orig,dummy))
01149       {
01150         retval--;
01151         fprintf (stderr, 
01152                  <span class="stringliteral">"ERROR: manoj_strcat Failed test %d. \n"</span>,
01153                  i);
01154         fprintf (stderr, 
01155                  <span class="stringliteral">"  orig (%s)\n dummy (%s)\n"</span>,
01156                  orig, dummy);
01157       } 
01158 <span class="preprocessor">#ifdef DEBUG</span>
01159 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01160       {
01161         fprintf (stderr, <span class="stringliteral">"."</span>);
01162       } <span class="comment">/* end of else */</span>
01163 <span class="preprocessor">#endif     </span>
01164 <span class="preprocessor"></span>   }
01165 <span class="preprocessor">#ifdef DEBUG</span>
01166 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01167 <span class="preprocessor">#endif  </span>
01168 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01169 }
01170 <span class="comment"></span>
01171 <span class="comment">/**</span>
01172 <span class="comment"> * @brief Test the manoj_strncat function</span>
01173 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01174 <span class="comment"> *</span>
01175 <span class="comment"> */</span>
<a name="l01176"></a><a class="code" href="string__test_8c.html#a18">01176</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a18">test_strncat</a>(<span class="keywordtype">void</span>)
01177 {
01178   <span class="keywordtype">int</span> retval = 0;
01179   <span class="keywordtype">char</span> buffer[1024];
01180   <span class="keywordtype">char</span> copy[1024];
01181   <span class="keywordtype">int</span> i = 0;
01182 
01183 <span class="preprocessor">#ifdef DEBUG</span>
01184 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strncat - "</span>); 
01185 <span class="preprocessor">#endif</span>
01186 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01187    {
01188      <span class="keywordtype">char</span> * orig  = 0;
01189      <span class="keywordtype">char</span> * dummy = 0;
01190      memset(buffer,0,1024);
01191      memset(copy,0,1024);
01192      (void) strcpy(buffer, <span class="stringliteral">"Original String "</span>);
01193      (void) strcpy(copy,   <span class="stringliteral">"Original String "</span>);
01194      orig  = <a class="code" href="string__test_8c.html#a17">manoj_strncat</a>(buffer, <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], 5);
01195      dummy =       strncat(copy,   <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], 5);
01196      <span class="keywordflow">if</span>(strcmp(orig,dummy))
01197       {
01198         retval--;
01199         fprintf (stderr, 
01200                  <span class="stringliteral">"ERROR: manoj_strncat Failed test %d. \n"</span>,
01201                  i);
01202         fprintf (stderr, 
01203                  <span class="stringliteral">"  orig (%s)\n dummy (%s)\n"</span>,
01204                  orig, dummy);
01205        } 
01206 <span class="preprocessor">#ifdef DEBUG</span>
01207 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01208       {
01209         fprintf (stderr, <span class="stringliteral">"."</span>);
01210       } <span class="comment">/* end of else */</span>
01211 <span class="preprocessor">#endif     </span>
01212 <span class="preprocessor"></span>   }
01213 <span class="preprocessor">#ifdef DEBUG</span>
01214 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01215 <span class="preprocessor">#endif  </span>
01216 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01217 }
01218 <span class="comment"></span>
01219 <span class="comment">/**</span>
01220 <span class="comment"> * @brief A macro to determine the signed state of an integer</span>
01221 <span class="comment"> *</span>
01222 <span class="comment"> * This is slightly misnamed, since it does distinguish between a 0</span>
01223 <span class="comment"> * value and positive values -- it really does return a tristate</span>
01224 <span class="comment"> * value, ideal for testing strcmp like function return values.</span>
01225 <span class="comment"> */</span>
<a name="l01226"></a><a class="code" href="string__test_8c.html#a3">01226</a> <span class="preprocessor">#define sign(x) (x&gt;0 ? 1 : (x&lt;0 ? -1 : 0))</span>
01227 <span class="preprocessor"></span><span class="comment"></span>
01228 <span class="comment">/**</span>
01229 <span class="comment"> * @brief Test the manoj_strcmp function</span>
01230 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01231 <span class="comment"> *</span>
01232 <span class="comment"> */</span>
<a name="l01233"></a><a class="code" href="string__test_8c.html#a20">01233</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a20">test_strcmp</a>(<span class="keywordtype">void</span>)
01234 {
01235   <span class="keywordtype">int</span> retval = 0;
01236   <span class="keywordtype">int</span> i = 0;
01237 
01238 <span class="preprocessor">#ifdef DEBUG</span>
01239 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strcmp - "</span>); 
01240 <span class="preprocessor">#endif</span>
01241 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01242    {
01243      <span class="keywordtype">int</span> m = <a class="code" href="string__test_8c.html#a19">manoj_strcmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>);
01244      <span class="keywordtype">int</span> o =       strcmp(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>);
01245 
01246      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a3">sign</a>(m) != <a class="code" href="string__test_8c.html#a3">sign</a>(o))
01247       {
01248         retval--;
01249         fprintf (stderr, 
01250                  <span class="stringliteral">"ERROR: manoj_strcmp Failed test %d. %d != %d\n"</span>,
01251                  i, m, o);
01252         fprintf (stderr, 
01253                  <span class="stringliteral">"ERROR: (%s) != (The long jump )  \n"</span>,
01254                  <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01255       } 
01256 <span class="preprocessor">#ifdef DEBUG</span>
01257 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01258       {
01259         fprintf (stderr, <span class="stringliteral">"."</span>);
01260       } <span class="comment">/* end of else */</span>
01261 <span class="preprocessor">#endif     </span>
01262 <span class="preprocessor"></span>   }
01263 <span class="preprocessor">#ifdef DEBUG</span>
01264 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01265 <span class="preprocessor">#endif  </span>
01266 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01267 }
01268 <span class="comment"></span>
01269 <span class="comment">/**</span>
01270 <span class="comment"> * @brief Test the manoj_strncat function</span>
01271 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01272 <span class="comment"> *</span>
01273 <span class="comment"> */</span>
<a name="l01274"></a><a class="code" href="string__test_8c.html#a22">01274</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a22">test_strncmp</a>(<span class="keywordtype">void</span>)
01275 {
01276   <span class="keywordtype">int</span> retval = 0;
01277   <span class="keywordtype">int</span> i = 0;
01278 
01279 <span class="preprocessor">#ifdef DEBUG</span>
01280 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strncmp - "</span>); 
01281 <span class="preprocessor">#endif</span>
01282 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01283    {
01284      <span class="keywordtype">int</span> m = <a class="code" href="string__test_8c.html#a21">manoj_strncmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>, 5);
01285      <span class="keywordtype">int</span> o = strncmp(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>, 5);
01286      
01287      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a3">sign</a>(m) != <a class="code" href="string__test_8c.html#a3">sign</a>(o))
01288       {
01289         retval--;
01290         fprintf (stderr, 
01291                  <span class="stringliteral">"ERROR: manoj_strncmp Failed test %d. %d != %d\n"</span>,
01292                  i, m, o);
01293         fprintf (stderr, 
01294                  <span class="stringliteral">"ERROR: (The long jump ) != (%s) \n"</span>,
01295                  <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]);
01296        } 
01297 <span class="preprocessor">#ifdef DEBUG</span>
01298 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01299       {
01300         fprintf (stderr, <span class="stringliteral">"."</span>);
01301       } <span class="comment">/* end of else */</span>
01302 <span class="preprocessor">#endif     </span>
01303 <span class="preprocessor"></span>   }
01304 <span class="preprocessor">#ifdef DEBUG</span>
01305 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01306 <span class="preprocessor">#endif  </span>
01307 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01308 }
01309 
01310 <span class="comment"></span>
01311 <span class="comment">/**</span>
01312 <span class="comment"> * @brief Test the manoj_strcasecmp function</span>
01313 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01314 <span class="comment"> *</span>
01315 <span class="comment"> */</span>
<a name="l01316"></a><a class="code" href="string__test_8c.html#a25">01316</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a25">test_strcasecmp</a>(<span class="keywordtype">void</span>)
01317 {
01318   <span class="keywordtype">int</span> retval = 0;
01319   <span class="keywordtype">int</span> i = 0;
01320 
01321 <span class="preprocessor">#ifdef DEBUG</span>
01322 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strcasecmp - "</span>); 
01323 <span class="preprocessor">#endif</span>
01324 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01325    {
01326      <span class="keywordtype">int</span> m = <a class="code" href="string__test_8c.html#a24">manoj_strcasecmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>);
01327      <span class="keywordtype">int</span> o = <a class="code" href="string__test_8c.html#a23">strcasecmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>);
01328      
01329      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a3">sign</a>(m) != <a class="code" href="string__test_8c.html#a3">sign</a>(o))
01330       {
01331         retval--;
01332         fprintf (stderr, 
01333                  <span class="stringliteral">"ERROR: manoj_strcasecmp Failed test %d. \n"</span>,
01334                  i);
01335       } 
01336 <span class="preprocessor">#ifdef DEBUG</span>
01337 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01338       {
01339         fprintf (stderr, <span class="stringliteral">"."</span>);
01340       } <span class="comment">/* end of else */</span>
01341 <span class="preprocessor">#endif     </span>
01342 <span class="preprocessor"></span>   }
01343 <span class="preprocessor">#ifdef DEBUG</span>
01344 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01345 <span class="preprocessor">#endif  </span>
01346 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01347 }
01348 <span class="comment"></span>
01349 <span class="comment">/**</span>
01350 <span class="comment"> * @brief Test the manoj_strncat function</span>
01351 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01352 <span class="comment"> *</span>
01353 <span class="comment"> */</span>
<a name="l01354"></a><a class="code" href="string__test_8c.html#a28">01354</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a28">test_strncasecmp</a>(<span class="keywordtype">void</span>)
01355 {
01356   <span class="keywordtype">int</span> retval = 0;
01357   <span class="keywordtype">int</span> i = 0;
01358 
01359 <span class="preprocessor">#ifdef DEBUG</span>
01360 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strncasecmp - "</span>); 
01361 <span class="preprocessor">#endif</span>
01362 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01363    {
01364      <span class="keywordtype">int</span> m = <a class="code" href="string__test_8c.html#a27">manoj_strncasecmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>, 5);
01365      <span class="keywordtype">int</span> o = <a class="code" href="string__test_8c.html#a26">strncasecmp</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"The long jump "</span>, 5);
01366      
01367      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a3">sign</a>(m) != <a class="code" href="string__test_8c.html#a3">sign</a>(o))
01368       {
01369         retval--;
01370         fprintf (stderr, 
01371                  <span class="stringliteral">"ERROR: manoj_strncasecmp Failed test %d. \n"</span>,
01372                  i);
01373        } 
01374 <span class="preprocessor">#ifdef DEBUG</span>
01375 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01376       {
01377         fprintf (stderr, <span class="stringliteral">"."</span>);
01378       } <span class="comment">/* end of else */</span>
01379 <span class="preprocessor">#endif     </span>
01380 <span class="preprocessor"></span>   }
01381 <span class="preprocessor">#ifdef DEBUG</span>
01382 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01383 <span class="preprocessor">#endif  </span>
01384 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01385 }
01386 <span class="comment"></span>
01387 <span class="comment">/**</span>
01388 <span class="comment"> * @brief Test the manoj_strnchr function</span>
01389 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01390 <span class="comment"> *</span>
01391 <span class="comment"> */</span>
<a name="l01392"></a><a class="code" href="string__test_8c.html#a30">01392</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a30">test_strchr</a>(<span class="keywordtype">void</span>)
01393 {
01394   <span class="keywordtype">int</span> retval = 0;
01395   <span class="keywordtype">int</span> i = 0;
01396 
01397 <span class="preprocessor">#ifdef DEBUG</span>
01398 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strchr - "</span>); 
01399 <span class="preprocessor">#endif</span>
01400 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01401    {
01402      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a29">manoj_strchr</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="charliteral">'j'</span>) != 
01403         strchr(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="charliteral">'j'</span>))
01404       {
01405         retval--;
01406         fprintf (stderr, 
01407                  <span class="stringliteral">"ERROR: manoj_strchr Failed test %d. \n"</span>,
01408                  i);
01409        } 
01410 <span class="preprocessor">#ifdef DEBUG</span>
01411 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01412       {
01413         fprintf (stderr, <span class="stringliteral">"."</span>);
01414       } <span class="comment">/* end of else */</span>
01415 <span class="preprocessor">#endif     </span>
01416 <span class="preprocessor"></span>   }
01417 <span class="preprocessor">#ifdef DEBUG</span>
01418 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01419 <span class="preprocessor">#endif  </span>
01420 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01421 }
01422 <span class="comment"></span>
01423 <span class="comment">/**</span>
01424 <span class="comment"> * @brief Test the manoj_strnchr function</span>
01425 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01426 <span class="comment"> *</span>
01427 <span class="comment"> */</span>
<a name="l01428"></a><a class="code" href="string__test_8c.html#a32">01428</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a32">test_strrchr</a>(<span class="keywordtype">void</span>)
01429 {
01430   <span class="keywordtype">int</span> retval = 0;
01431   <span class="keywordtype">int</span> i = 0;
01432 
01433 <span class="preprocessor">#ifdef DEBUG</span>
01434 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strrchr - "</span>); 
01435 <span class="preprocessor">#endif</span>
01436 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01437    {
01438      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a31">manoj_strrchr</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="charliteral">'j'</span>) != 
01439         strrchr(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="charliteral">'j'</span>))
01440       {
01441         retval--;
01442         fprintf (stderr, 
01443                  <span class="stringliteral">"ERROR: manoj_strrchr Failed test %d. \n"</span>,
01444                  i);
01445        } 
01446 <span class="preprocessor">#ifdef DEBUG</span>
01447 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01448       {
01449         fprintf (stderr, <span class="stringliteral">"."</span>);
01450       } <span class="comment">/* end of else */</span>
01451 <span class="preprocessor">#endif     </span>
01452 <span class="preprocessor"></span>   }
01453 <span class="preprocessor">#ifdef DEBUG</span>
01454 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01455 <span class="preprocessor">#endif  </span>
01456 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01457 }
01458 <span class="comment"></span>
01459 <span class="comment">/**</span>
01460 <span class="comment"> * @brief Test the manoj_strtok function</span>
01461 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01462 <span class="comment"> *</span>
01463 <span class="comment"> */</span>
<a name="l01464"></a><a class="code" href="string__test_8c.html#a34">01464</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a34">test_strtok</a>(<span class="keywordtype">void</span>)
01465 {
01466   <span class="keywordtype">int</span>            retval   = 0;
01467   <span class="keywordtype">int</span>            i        = 0;
01468   <span class="keywordtype">char</span>          *buffer_p = 0;
01469   <span class="keywordtype">char</span>          *copy_p   = 0;
01470   <span class="keyword">const</span> <span class="keywordtype">char</span>    *delim_p  = <span class="stringliteral">" eta"</span>;
01471   <span class="keywordtype">char</span>          *tok1     = 0;
01472   <span class="keywordtype">char</span>          *tok2     = 0;
01473   
01474   
01475 <span class="preprocessor">#ifdef DEBUG</span>
01476 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strtok - "</span>); 
01477 <span class="preprocessor">#endif</span>
01478 <span class="preprocessor"></span>
01479   buffer_p = malloc(128);
01480   <span class="keywordflow">if</span>(! buffer_p) <span class="keywordflow">return</span> -1;
01481 
01482   copy_p = malloc(128);
01483   <span class="keywordflow">if</span>(! copy_p) <span class="keywordflow">return</span> -1;
01484 
01485   (void) strcpy(buffer_p, <span class="stringliteral">"The quick brown fox jumps over the lazy dog"</span>);
01486   (void) strcpy(copy_p,   <span class="stringliteral">"The quick brown fox jumps over the lazy dog"</span>);
01487 
01488   tok1 = <a class="code" href="string__test_8c.html#a33">manoj_strtok</a>(buffer_p, delim_p);
01489   tok2 =       strtok(copy_p,   delim_p);
01490   <span class="keywordflow">if</span>(strcmp(tok1, tok2))
01491    {
01492      retval--;
01493      fprintf (stderr, 
01494               <span class="stringliteral">"ERROR: manoj_strtok Failed test %d. Got (%s), expected (%s)\n"</span>,
01495               i++, tok1, tok2);
01496    } 
01497 <span class="preprocessor">#ifdef DEBUG</span>
01498 <span class="preprocessor"></span>  <span class="keywordflow">else</span>
01499    {
01500      fprintf (stderr, <span class="stringliteral">"."</span>);
01501    } 
01502 <span class="preprocessor">#endif     </span>
01503 <span class="preprocessor"></span>
01504   <span class="keywordflow">while</span>((tok1 =  <a class="code" href="string__test_8c.html#a33">manoj_strtok</a>(0, delim_p)))
01505    {
01506      tok2 = strtok(0, delim_p);
01507      <span class="keywordflow">if</span>(strcmp(tok1, tok2))
01508       {
01509         retval--;
01510         fprintf(stderr, 
01511                 <span class="stringliteral">"ERROR: manoj_strtok Failed test %d. Got (%s), expected (%s)\n"</span>,
01512                  i++, tok1, tok2);
01513       } 
01514 <span class="preprocessor">#ifdef DEBUG</span>
01515 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01516       {
01517         fprintf (stderr, <span class="stringliteral">"."</span>);
01518       } 
01519 <span class="preprocessor">#endif     </span>
01520 <span class="preprocessor"></span>   }
01521 <span class="preprocessor">#ifdef DEBUG</span>
01522 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01523 <span class="preprocessor">#endif  </span>
01524 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01525 }
01526 
01527 <span class="comment"></span>
01528 <span class="comment">/**</span>
01529 <span class="comment"> * @brief Test the manoj_strtok_r function</span>
01530 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01531 <span class="comment"> *</span>
01532 <span class="comment"> */</span>
<a name="l01533"></a><a class="code" href="string__test_8c.html#a37">01533</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a37">test_strtok_r</a>(<span class="keywordtype">void</span>)
01534 {
01535   <span class="keywordtype">int</span>            retval   = 0;
01536   <span class="keywordtype">int</span>            i        = 0;
01537   <span class="keywordtype">char</span>          *orig_p   = 0;
01538   <span class="keywordtype">char</span>          *buffer_p = 0;
01539   <span class="keywordtype">char</span>          *copy_p   = 0;
01540   <span class="keyword">const</span> <span class="keywordtype">char</span>    *delim_p  = <span class="stringliteral">" eta"</span>;
01541   <span class="keywordtype">char</span>          *tok1     = 0;
01542   <span class="keywordtype">char</span>          *tok2     = 0;
01543 
01544   
01545 <span class="preprocessor">#ifdef DEBUG</span>
01546 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strtok_r - "</span>); 
01547 <span class="preprocessor">#endif</span>
01548 <span class="preprocessor"></span>
01549   orig_p = malloc(128);
01550   <span class="keywordflow">if</span>(! orig_p) <span class="keywordflow">return</span> -1;
01551 
01552   buffer_p = malloc(128);
01553   <span class="keywordflow">if</span>(! buffer_p) <span class="keywordflow">return</span> -1;
01554 
01555   copy_p = malloc(128);
01556   <span class="keywordflow">if</span>(! copy_p) <span class="keywordflow">return</span> -1;
01557 
01558   (void) strcpy(orig_p, <span class="stringliteral">"The quick brown fox jumps over the lazy dog"</span>);
01559 
01560   tok1 = <a class="code" href="string__test_8c.html#a36">manoj_strtok_r</a>(orig_p, delim_p, &amp;buffer_p);
01561   tok2 =       <a class="code" href="string__test_8c.html#a35">strtok_r</a>(orig_p, delim_p, &amp;copy_p);
01562   <span class="keywordflow">if</span>(strcmp(tok1, tok2))
01563    {
01564      retval--;
01565      fprintf (stderr, 
01566               <span class="stringliteral">"ERROR: manoj_strtok_r Failed test %d. Got (%s), expected (%s)\n"</span>,
01567               i++, tok1, tok2);
01568    } 
01569 <span class="preprocessor">#ifdef DEBUG</span>
01570 <span class="preprocessor"></span>  <span class="keywordflow">else</span>
01571    {
01572      fprintf (stderr, <span class="stringliteral">"."</span>);
01573    } 
01574 <span class="preprocessor">#endif     </span>
01575 <span class="preprocessor"></span>
01576   <span class="keywordflow">while</span>((tok1 =  <a class="code" href="string__test_8c.html#a36">manoj_strtok_r</a>(0, delim_p, &amp;buffer_p)))
01577    {
01578      tok2 = <a class="code" href="string__test_8c.html#a35">strtok_r</a>(0, delim_p, &amp;copy_p);
01579      <span class="keywordflow">if</span>(strcmp(tok1, tok2))
01580       {
01581         retval--;
01582         fprintf (stderr, 
01583                  <span class="stringliteral">"ERROR: manoj_strtok_r Failed test %d. Got (%s), expected (%s)\n"</span>,
01584                  i++, tok1, tok2);
01585       } 
01586 <span class="preprocessor">#ifdef DEBUG</span>
01587 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01588       {
01589         fprintf (stderr, <span class="stringliteral">"."</span>);
01590       } 
01591 <span class="preprocessor">#endif     </span>
01592 <span class="preprocessor"></span>   }
01593 <span class="preprocessor">#ifdef DEBUG</span>
01594 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01595 <span class="preprocessor">#endif  </span>
01596 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01597 }
01598 <span class="comment"></span>
01599 <span class="comment">/**</span>
01600 <span class="comment"> * @brief Test the manoj_strtsr function</span>
01601 <span class="comment"> * @return 0 on success, a negative integer on failure</span>
01602 <span class="comment"> *</span>
01603 <span class="comment"> */</span>
<a name="l01604"></a><a class="code" href="string__test_8c.html#a39">01604</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a39">test_strstr</a>(<span class="keywordtype">void</span>)
01605 {
01606   <span class="keywordtype">int</span>            retval   = 0;
01607   <span class="keywordtype">int</span>            i        = 0;
01608   
01609 <span class="preprocessor">#ifdef DEBUG</span>
01610 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">"manoj_strstr - "</span>); 
01611 <span class="preprocessor">#endif</span>
01612 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; <a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i]; i++)
01613    {
01614      <span class="keywordflow">if</span>(<a class="code" href="string__test_8c.html#a38">manoj_strstr</a>(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"at-that"</span>) != 
01615         strstr(<a class="code" href="string__test_8c.html#a6">strings_to_test</a>[i], <span class="stringliteral">"at-that"</span>))
01616       {
01617         retval--;
01618         fprintf (stderr, 
01619                  <span class="stringliteral">"ERROR: manoj_strstr Failed test %d. \n"</span>,
01620                  i);
01621        } 
01622 <span class="preprocessor">#ifdef DEBUG</span>
01623 <span class="preprocessor"></span>     <span class="keywordflow">else</span>
01624       {
01625         fprintf (stderr, <span class="stringliteral">"."</span>);
01626       } <span class="comment">/* end of else */</span>
01627 <span class="preprocessor">#endif     </span>
01628 <span class="preprocessor"></span>   }
01629 <span class="preprocessor">#ifdef DEBUG</span>
01630 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">" - done\n"</span>);
01631 <span class="preprocessor">#endif  </span>
01632 <span class="preprocessor"></span>  <span class="keywordflow">return</span> retval;
01633 }
01634 
01635 <span class="comment"></span>
01636 <span class="comment">/**</span>
01637 <span class="comment"> * @brief The main entry point for this testing routine</span>
01638 <span class="comment"> * @return EXIT_SUCCESS on success, EXIT_FAILURE oterwise</span>
01639 <span class="comment"> */</span>
<a name="l01640"></a><a class="code" href="string__test_8c.html#a40">01640</a> <span class="keywordtype">int</span> <a class="code" href="string__test_8c.html#a40">main</a>(<span class="keywordtype">void</span>)
01641 {
01642   <span class="keywordtype">int</span>   retval   = 0;
01643   <span class="keywordtype">int</span>   retval1  = 0;
01644   <span class="keywordtype">int</span>   retval2  = 0;
01645   <span class="keywordtype">int</span>   retval3  = 0;
01646   <span class="keywordtype">int</span>   retval4  = 0;
01647   <span class="keywordtype">int</span>   retval5  = 0;
01648   <span class="keywordtype">int</span>   retval6  = 0;
01649   <span class="keywordtype">int</span>   retval7  = 0;
01650   <span class="keywordtype">int</span>   retval8  = 0;
01651   <span class="keywordtype">int</span>   retval9  = 0;
01652   <span class="keywordtype">int</span>   retval10 = 0;
01653   <span class="keywordtype">int</span>   retval11 = 0;
01654   <span class="keywordtype">int</span>   retval12 = 0;
01655   <span class="keywordtype">int</span>   retval13 = 0;
01656   <span class="keywordtype">int</span>   retval14 = 0;
01657 
01658   fprintf (stderr, <span class="stringliteral">"stringtest Version %s\n\n"</span>, <a class="code" href="string__test_8c.html#a4">version</a>);
01659   
01660   retval = <a class="code" href="string__test_8c.html#a8">test_strlen</a>();
01661   <span class="keywordflow">if</span>(retval)   fprintf (stderr, <span class="stringliteral">"strlen Test Failed\n"</span>);
01662 
01663   retval1 = <a class="code" href="string__test_8c.html#a10">test_strcpy</a>();
01664   <span class="keywordflow">if</span>(retval1)  fprintf (stderr, <span class="stringliteral">"strcpy Test Failed\n"</span>);
01665 
01666   retval2 = <a class="code" href="string__test_8c.html#a12">test_strncpy</a>();
01667   <span class="keywordflow">if</span>(retval2)  fprintf (stderr, <span class="stringliteral">"strncpy Test Failed\n"</span>);
01668 
01669   retval3 = <a class="code" href="string__test_8c.html#a14">test_strdup</a>();
01670   <span class="keywordflow">if</span>(retval3)  fprintf (stderr, <span class="stringliteral">"strdup Test Failed\n"</span>);
01671 
01672   retval4 = <a class="code" href="string__test_8c.html#a16">test_strcat</a>();
01673   <span class="keywordflow">if</span>(retval4)  fprintf (stderr, <span class="stringliteral">"strcat Test Failed\n"</span>);
01674 
01675   retval5 = <a class="code" href="string__test_8c.html#a18">test_strncat</a>();
01676   <span class="keywordflow">if</span>(retval5)  fprintf (stderr, <span class="stringliteral">"strncat Test Failed\n"</span>);
01677 
01678   retval6 = <a class="code" href="string__test_8c.html#a20">test_strcmp</a>();
01679   <span class="keywordflow">if</span>(retval6)  fprintf (stderr, <span class="stringliteral">"strncmp Test Failed\n"</span>);
01680 
01681   retval7 = <a class="code" href="string__test_8c.html#a22">test_strncmp</a>();
01682   <span class="keywordflow">if</span>(retval7)  fprintf (stderr, <span class="stringliteral">"strncmp Test Failed\n"</span>);
01683 
01684   retval8 = <a class="code" href="string__test_8c.html#a25">test_strcasecmp</a>();
01685   <span class="keywordflow">if</span>(retval8)  fprintf (stderr, <span class="stringliteral">"strcat Test Failed\n"</span>);
01686 
01687   retval9 = <a class="code" href="string__test_8c.html#a28">test_strncasecmp</a>();
01688   <span class="keywordflow">if</span>(retval9)  fprintf (stderr, <span class="stringliteral">"strncasecmp Test Failed\n"</span>);
01689 
01690   retval10 = <a class="code" href="string__test_8c.html#a30">test_strchr</a>();
01691   <span class="keywordflow">if</span>(retval10)  fprintf (stderr, <span class="stringliteral">"strchr Test Failed\n"</span>);
01692 
01693   retval11 = <a class="code" href="string__test_8c.html#a32">test_strrchr</a>();
01694   <span class="keywordflow">if</span>(retval11)  fprintf (stderr, <span class="stringliteral">"strrchr Test Failed\n"</span>);
01695 
01696   retval12 = <a class="code" href="string__test_8c.html#a34">test_strtok</a>();
01697   <span class="keywordflow">if</span>(retval12)  fprintf (stderr, <span class="stringliteral">"strtok Test Failed\n"</span>);
01698 
01699   retval13 = <a class="code" href="string__test_8c.html#a37">test_strtok_r</a>();
01700   <span class="keywordflow">if</span>(retval13)  fprintf (stderr, <span class="stringliteral">"strtok_r Test Failed\n"</span>);
01701 
01702   retval14 = <a class="code" href="string__test_8c.html#a39">test_strstr</a>();
01703   <span class="keywordflow">if</span>(retval14)  fprintf (stderr, <span class="stringliteral">"strstr Test Failed\n"</span>);
01704 
01705   <span class="keywordflow">if</span>(!(retval   + retval1  + retval2  + retval3  + retval4  + retval5  +
01706        retval6  + retval7  + retval8  + retval9  + retval10 + retval11 +
01707        retval12 + retval13 + retval14))
01708    {
01709      fprintf (stderr, <span class="stringliteral">"\n\tSuccess\n"</span>);
01710       exit (EXIT_SUCCESS);
01711    }
01712   exit (EXIT_FAILURE);
01713 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Nov 7 19:05:05 2004 for TEST_STRINGS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
